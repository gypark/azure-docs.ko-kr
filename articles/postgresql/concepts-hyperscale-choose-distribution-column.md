---
title: Azure Database for PostgreSQL – 하이퍼스케일(Citus)(미리 보기)에서 분산 열 선택
description: 일반적인 하이퍼스케일 시나리오에서 분산 열에 대한 적절한 선택
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: e9fba14b8979f739fd29bc277e32fb544221d08a
ms.sourcegitcommit: 0ae3139c7e2f9d27e8200ae02e6eed6f52aca476
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/06/2019
ms.locfileid: "65078987"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus-preview"></a>Azure Database for PostgreSQL – 하이퍼스케일(Citus)(미리 보기)에서 분산 열 선택

각 테이블의 분산 열을 선택하는 것은 모델링 의사결정에서 **가장 중요한 것 중 하나**입니다. 하이퍼스케일은 분산 열 행의 값을 기반으로 하는 분할에 행을 저장합니다.


올바른 선택은 동일한 물리적 노드에서 관련 데이터를 함께 그룹핑하여, 모든 SQL 기능에 대한 지원을 추가하고 쿼리를 빠르게 합니다. 잘못된 선택은 시스템을 느리게 하며 노드에 걸쳐 모든 SQL 기능을 지원하지 않습니다.


이 섹션에서는 가장 일반적인 두 가지 하이퍼스케일 시나리오에 대한 분산 열 팁을 제공합니다.

### <a name="multi-tenant-apps"></a>다중 테넌트 앱


다중 테넌트 아키텍처는 서버 그룹의 노드 간에 쿼리를 분산하기 위해 계층적인 데이터베이스 모델링의 형태를 사용합니다. 데이터 계층의 최상위는 *테넌트 ID*라고 하며, 각 테이블의 열에 저장되어야 합니다.


하이퍼스케일은 쿼리를 조사하여 관련 테넌트 ID를 확인하고 일치하는 테이블 분할을 찾습니다. 분할을 포함하는 단일 작업자 노드로 쿼리를 라우팅합니다. 같은 노드에 있는 모든 관련 데이터를 사용하여 쿼리를 실행하는 것을 공동 배치라고 합니다.

다음 다이어그램에서는 다중 테넌트 데이터 모델에서의 공동 배치를 보여줍니다. Accounts 및 Campaigns 두 개의 테이블을 포함하며, 각각 `account_id`로 분산됩니다. 회색 상자는 분할을 포함하는 작업자 노드를 나타내는 해당 색의 분할을 나타냅니다. 녹색 분할은 하나의 작업자 노드에 함께 저장되고 파란색은 다른 노드에 저장됩니다. 동일한 account_id로 두 테이블을 제한하는 경우 Accounts 및 Campaigns 간의 join 쿼리가 한 노드에서 필요한 모든 데이터를 함께 포함하는 방식에 주목하세요.

![다중 테 넌 트 공동 배치](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

사용자 고유의 스키마에서 이 디자인을 적용하려면 응용 프로그램에서 테넌트 구성 요소를 식별합니다. 일반적인 인스턴스는 회사, 계정, 조직 또는 고객을 포함합니다. 열 이름은 `company_id` 또는 `customer_id`와 같이 표시됩니다. 각 쿼리를 검토하고 자신에게 질문합니다:동일한 테넌트 ID를 가진 행에 관련된 모든 테이블을 제한하기 위해 WHERE 절을 추가한다면 작동할까?

다중 테넌트 모델에서 쿼리는 한 테넌트로 범위가 지정되어, 예를 들어 Sales 또는 inventory에 대한 쿼리는 특정 저장소 내로 범위가 지정됩니다.

#### <a name="best-practices"></a>모범 사례

- **공통 tenant_id 열로 분산된 테이블을 파티션합니다.** 예를 들어, 테넌트가 회사들인 SaaS 응용 프로그램에서 tenant_id는 company_id가 될 것입니다.
- **작은 테넌트 간 테이블을 참조 테이블로 변환합니다.** 여러 테넌트가 작은 테이블의 정보를 공유하는 경우 참조 테이블로 분산합니다.
- **tenant_id로 모든 응용 프로그램 쿼리를 필터하여 제한합니다.** 각 쿼리는 한 번에 하나의 테넌트에 대한 정보를 요청해야 합니다.


이 종류의 응용 프로그램을 구축하는 예제는 [다중 테넌트 자습서](./tutorial-design-database-hyperscale-multi-tenant.md)를 확인합니다.

### <a name="real-time-apps"></a>실시간 앱

다중 테넌트 아키텍처는 계층 구조를 도입하고 테넌트별로 쿼리를 라우팅하도록 데이터 공동 배치를 사용합니다. 반면, 실시간 아키텍처는 높은 병렬 처리를 위해 해당 데이터의 특정 분산 속성에 따라 달라 집니다.

실시간 모델에서 분산 열에 대한 용어로 "엔터티 ID"를 사용합니다. 일반적인 엔터티는 사용자, 호스트 또는 장치입니다.

실시간 쿼리는 일반적으로 날짜 또는 범주별으로 그룹화하는 숫자 집계를 요청합니다. 하이퍼스케일은 부분 결과에 대한 각 분할에 이러한 쿼리를 보내고 코디네이터 노드에서 최종 해답을 조합합니다. 쿼리는 최대한 많은 노드가 참여하고 불균형한 양의 작업을 수행하는 단일 노드가 없는 경우 가장 빠르게 실행됩니다.

#### <a name="best-practices"></a>모범 사례


- **분산 열로 카디널리티가 높은 열을 선택합니다.** 비교하자면, "신규", "유료", "배송"을 값을 가지는 주문 테이블의 "상태" 필드는 잘못된 분산 열 선택입니다. 이 경우 데이터를 보유할 수 있는 분할 수와 처리할 수 있는 노드의 수를 제한하는 몇 가지 값만을 가정합니다. 카디널리티가 높은 열 간에 조인 키 또는 group by 절에서 자주 사용되는 것을 선택하면 더욱 좋습니다.
- **균등한 분산의 열을 선택합니다.** 특정 공통값으로 비대칭인 열에 테이블을 분산하면 테이블의 데이터가 특정 분할에 누적되는 경향이 있습니다. 이러한 분할을 보유한 노드는 다른 노드보다 많은 작업을 수행하게 됩니다.
- **공통 열 기준으로 팩트 테이블과 차원 테이블을 분산합니다.**
    팩트 테이블은 하나의 분산 키만 있을 수 있습니다. 다른 키에 조인하는 테이블은 팩트 테이블을 사용하여 공동 배치되지 않습니다. 조인되는 빈도와 조인하는 행의 크기에 따라 공동 배치할 수 있는 하나 이상의 차원을 선택합니다.
- **일부 차원 테이블을 참조 테이블로 변경합니다.** 차원 테이블은 팩트 테이블을 사용하여 공동 배치할 수 없는 경우 참조 테이블의 형태로 모든 노드의 차원 테이블의 복사본을 분산하여 쿼리 성능을 개선할 수 있습니다.


이 종류의 응용 프로그램을 구축하는 예제는 [실시간 대시보드 자습서](./tutorial-design-database-hyperscale-realtime.md)를 확인합니다.

### <a name="timeseries-data"></a>시계열 데이터

시계열 워크로드에서 응용 프로그램은 이전 정보를 보관하는 동안 최신 정보를 쿼리합니다.

하이퍼스케일의 시계열 정보 모델링에서 가장 일반적인 실수는 타임 스탬프 자체를 분산 열로 사용하는 것입니다. 시간을 기반으로 하는 해시 분산은 분할에 시간 범위를 함께 유지하는 것이 아니라 다른 분할로 랜덤으로 시간을 분산합니다. 시간과 관련된 쿼리는 일반적으로 시간 범위를 참조하여(예: 가장 최근의 데이터) 이러한 해시 분산은 네트워크 오버헤드를 발생시킵니다.

#### <a name="best-practices"></a>모범 사례


- **배포 열로 타임 스탬프를 선택하지 마세요.** 다른 배포 열을 선택합니다. 다중 테넌트 앱에서 테넌트 ID를 사용하거나 실시간 앱에서 엔터티 ID를 사용합니다.
- **시간 대신 PostgreSQL 테이블 파티셔닝을 사용합니다.** 큰 테이블의 시간 정렬 데이터를 각각 다른 시간 범위를 포함하는 여러 상속된 테이블로 쪼개기 위해 테이블 파티셔닝을 사용합니다. 하이퍼스케일에서 Postgres 파티셔닝된 테이블의 분산은 상속된 테이블에 대한 분할을 만듭니다.



이 종류의 응용 프로그램을 구축하는 예제는 [시계열 자습서](https://aka.ms/hyperscale-tutorial-timeseries)를 확인합니다.

## <a name="next-steps"></a>다음 단계
- 분산된 데이터 쿼리 간의 [공동 배치](concepts-hyperscale-colocation.md)로 쿼리를 빠르게 실행하는 방법에 대해 알아봅니다.
